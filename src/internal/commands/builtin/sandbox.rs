use std::collections::BTreeMap;
use std::fs;
use std::path::{Component, Path, PathBuf};
use std::process::exit;

use crate::internal::commands::base::BuiltinCommand;
use crate::internal::commands::Command;
use crate::internal::config::config;
use crate::internal::config::parser::ParseArgsValue;
use crate::internal::config::CommandSyntax;
use crate::internal::config::SyntaxOptArg;
use crate::internal::config::SyntaxOptArgType;
use crate::internal::user_interface::StringColor;
use crate::internal::workdir_or_init;
use crate::omni_error;
use crate::omni_info;
use petname::{Generator, Petnames};

#[derive(Debug, Clone)]
struct SandboxCommandArgs {
    path: Option<PathBuf>,
    name: Option<String>,
    dependencies: Vec<String>,
}

impl From<BTreeMap<String, ParseArgsValue>> for SandboxCommandArgs {
    fn from(args: BTreeMap<String, ParseArgsValue>) -> Self {
        let path = match args.get("path") {
            Some(ParseArgsValue::SingleString(Some(value))) => {
                if value.trim().is_empty() {
                    None
                } else {
                    Some(PathBuf::from(value))
                }
            }
            _ => None,
        };

        let name = match args.get("name") {
            Some(ParseArgsValue::SingleString(Some(value))) => {
                if value.trim().is_empty() {
                    None
                } else {
                    Some(value.clone())
                }
            }
            _ => None,
        };

        let dependencies = match args.get("dependencies") {
            Some(ParseArgsValue::ManyString(values)) => {
                values.iter().flat_map(|item| item.clone()).collect()
            }
            _ => vec![],
        };

        Self {
            path,
            name,
            dependencies,
        }
    }
}

#[derive(Debug, Clone)]
pub struct SandboxCommand;

impl SandboxCommand {
    pub fn new() -> Self {
        Self
    }

    fn sandbox_root(&self) -> PathBuf {
        PathBuf::from(config(".").sandbox())
    }

    fn resolve_target(&self, name: &str) -> Result<PathBuf, String> {
        if name.trim().is_empty() {
            return Err("sandbox name cannot be empty".to_string());
        }

        let path = Path::new(name);
        if path.is_absolute() {
            return Err("sandbox name must be relative".to_string());
        }

        if path
            .components()
            .any(|component| matches!(component, Component::ParentDir))
        {
            return Err("sandbox name cannot navigate outside the sandbox root".to_string());
        }

        let root = self.sandbox_root();

        if let Err(err) = fs::create_dir_all(&root) {
            return Err(format!(
                "failed to create sandbox root '{}': {}",
                root.display(),
                err
            ));
        }

        Ok(root.join(path))
    }

    fn generate_sandbox_name(&self) -> Result<String, String> {
        let petname = Petnames::default()
            .generate_one(3, "-")
            .ok_or_else(|| "failed to generate sandbox name".to_string())?;
        Ok(petname)
    }

    fn write_config(&self, target: &Path, dependencies: &[String]) -> Result<(), String> {
        let config_path = target.join(".omni.yaml");

        if config_path.exists() {
            return Err(format!(
                "configuration file '{}' already exists",
                config_path.display()
            ));
        }

        let mut contents = String::new();
        contents.push_str("# Generated by omni sandbox\n");
        contents.push_str("up:\n");
        if dependencies.is_empty() {
            contents.push_str("  # Add your dependencies here, for example:\n");
            contents.push_str("  # - go\n");
            contents.push_str("  # - python\n");
        } else {
            for dependency in dependencies {
                contents.push_str(&format!("  - {dependency}\n"));
            }
        }
        if !contents.ends_with('\n') {
            contents.push('\n');
        }

        fs::write(&config_path, contents).map_err(|err| {
            format!(
                "failed to write configuration file '{}': {}",
                config_path.display(),
                err
            )
        })
    }

    fn initialize_workdir(&self, target: &Path) -> Result<(), String> {
        workdir_or_init(
            target
                .to_str()
                .ok_or_else(|| "failed to resolve sandbox path".to_string())?,
        )
        .map(|_| ())
        .map_err(|err| format!("failed to initialize sandbox: {err}"))
    }

    fn determine_target_path(&self, args: &SandboxCommandArgs) -> Result<(PathBuf, bool), String> {
        if let Some(path) = &args.path {
            return Ok((path.clone(), true));
        }

        if let Some(name) = &args.name {
            let target = self.resolve_target(name)?;
            if target.exists() {
                return Err(format!(
                    "sandbox destination '{}' already exists",
                    target.display()
                ));
            }
            return Ok((target, false));
        }

        let root = self.sandbox_root();
        if let Err(err) = fs::create_dir_all(&root) {
            return Err(format!(
                "failed to create sandbox root '{}': {}",
                root.display(),
                err
            ));
        }

        for _ in 0..100 {
            let name = self
                .generate_sandbox_name()
                .map_err(|err| format!("failed to generate sandbox name: {err}"))?;
            let target = root.join(&name);
            if !target.exists() {
                return Ok((target, false));
            }
        }

        Err("failed to generate a unique sandbox name".to_string())
    }

    fn initialize_at(
        &self,
        target: &Path,
        dependencies: &[String],
        allow_existing: bool,
    ) -> Result<PathBuf, String> {
        if target.exists() {
            if !target.is_dir() {
                return Err(format!(
                    "sandbox destination '{}' exists and is not a directory",
                    target.display()
                ));
            }

            if !allow_existing {
                return Err(format!(
                    "sandbox destination '{}' already exists",
                    target.display()
                ));
            }

            if target.join(".omni").join("id").exists() {
                return Err(format!(
                    "sandbox destination '{}' already contains a work directory",
                    target.display()
                ));
            }

            if target.join(".git").is_dir() {
                return Err(format!(
                    "sandbox destination '{}' already contains a git repository",
                    target.display()
                ));
            }

            if target.join(".omni.yaml").exists() {
                return Err(format!(
                    "sandbox destination '{}' already has an .omni.yaml file",
                    target.display()
                ));
            }
        } else if let Err(err) = fs::create_dir_all(target) {
            return Err(format!(
                "failed to create sandbox directory '{}': {}",
                target.display(),
                err
            ));
        }

        self.write_config(target, dependencies)?;
        self.initialize_workdir(target)?;

        Ok(target.to_path_buf())
    }
}

impl BuiltinCommand for SandboxCommand {
    fn new_boxed() -> Box<dyn BuiltinCommand> {
        Box::new(Self::new())
    }

    fn clone_boxed(&self) -> Box<dyn BuiltinCommand> {
        Box::new(self.clone())
    }

    fn name(&self) -> Vec<String> {
        vec!["sandbox".to_string()]
    }

    fn aliases(&self) -> Vec<Vec<String>> {
        vec![]
    }

    fn help(&self) -> Option<String> {
        let sandbox_root = self.sandbox_root();
        let sandbox_root_display = sandbox_root.display();

        Some(format!(
            concat!(
                "Create a sandbox directory pre-configured for omni.\n",
                "\n",
                "The sandbox name is generated automatically unless you pass \x1B[36m--name\x1B[0m.\n",
                "The sandbox is created under {} unless a specific path is provided with \x1B[36m--path\x1B[0m. ",
                "Additional arguments become entries under the `up` section in the generated .omni.yaml.\n",
                "\n",
                "If the target directory already contains a work directory or repository, the command will fail. ",
                "Existing .omni.yaml files are left untouched."
            ),
            sandbox_root_display
        ))
    }

    fn syntax(&self) -> Option<CommandSyntax> {
        Some(CommandSyntax {
            parameters: vec![
                SyntaxOptArg {
                    names: vec!["-p".to_string(), "--path".to_string()],
                    desc: Some(
                        "Path for the sandbox directory. Relative paths are resolved against the current directory."
                            .to_string(),
                    ),
                    conflicts_with: vec!["name".to_string()],
                    arg_type: SyntaxOptArgType::DirPath,
                    ..Default::default()
                },
                SyntaxOptArg {
                    names: vec!["-n".to_string(), "--name".to_string()],
                    desc: Some("Name for the sandbox directory.".to_string()),
                    conflicts_with: vec!["path".to_string()],
                    arg_type: SyntaxOptArgType::String,
                    ..Default::default()
                },
                SyntaxOptArg {
                    names: vec!["dependencies".to_string()],
                    desc: Some(
                        "Optional dependencies to add under the `up` section of the generated configuration."
                            .to_string(),
                    ),
                    leftovers: true,
                    allow_hyphen_values: true,
                    ..Default::default()
                },
            ],
            ..Default::default()
        })
    }

    fn category(&self) -> Option<Vec<String>> {
        Some(vec!["Work directories".to_string()])
    }

    fn exec(&self, argv: Vec<String>) {
        let command = Command::Builtin(self.clone_boxed());
        let args = SandboxCommandArgs::from(
            command
                .exec_parse_args_typed(argv, self.name())
                .expect("should have args to parse"),
        );

        let (target_path, allow_existing) = match self.determine_target_path(&args) {
            Ok(value) => value,
            Err(err) => {
                omni_error!(err);
                exit(1);
            }
        };

        let init_result = self.initialize_at(&target_path, &args.dependencies, allow_existing);

        let target = match init_result {
            Ok(target) => target,
            Err(err) => {
                omni_error!(err);
                exit(1);
            }
        };

        let target_display = target.to_string_lossy().to_string();
        omni_info!(format!(
            "sandbox initialized at {}",
            target_display.light_blue()
        ));

        exit(0);
    }
}

#[cfg(test)]
#[path = "sandbox_test.rs"]
mod tests;
